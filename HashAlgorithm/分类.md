### 安全加密

>最常用于加密的哈希算法是
MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和SHA（Secure Hash
Algorithm，安全散列算法）。除了这两个之外，当然还有很多其他加密算法，比如DES（Data Encryption Standard，
数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。
> 
> 


##### 哈希冲突的原因


这里就基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。这个原理本身很
简单，它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1
个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。

那为什么哈希算法无法做到零冲突？

>我们知道，哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 MD5 的例子，哈
希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而
我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就
必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，
散列冲突的概率越低。
> 
> 
### 唯一标识


如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片
的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不
同图片内容相同的情况。那我们该如何搜索呢？


我们知道，任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查
找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在
图库中存在。但是，每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的
串，比对起来非常耗时。有没有比较快的方法呢？

我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制
码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300
个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯
一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。

如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路
径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算
法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。

如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路
径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如
果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同
的图片。

### 数据校验

我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面
讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计
算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算
法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说
明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。


### 散列函数


### 负载均衡

我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话
粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一
次会话中的所有请求都路由到同一个服务器上。


### 数据分片

### 分布式存储